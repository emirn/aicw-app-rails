/**
 * Astro Integration for Image Validation
 *
 * Validates that all image references in articles point to existing files.
 * Runs in the astro:build:done hook before OG image generation.
 *
 * Rules:
 * - image_hero references a missing file → FAIL BUILD
 * - image_hero is empty/missing → OK (fallback to first body image)
 * - Body image references a missing file → FAIL BUILD
 * - External URLs (http/https) → SKIP
 * - image_og references a missing file → WARNING only (generated by og-images integration)
 */

import type { AstroIntegration } from 'astro';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';

interface ArticleFrontmatter {
  title?: string;
  image_hero?: string;
  image_og?: string;
}

interface ImageIssue {
  slug: string;
  imagePath: string;
  source: 'image_hero' | 'image_og' | 'body';
  severity: 'error' | 'warning';
}

/**
 * Parse YAML frontmatter from markdown content
 */
function parseFrontmatter(content: string): { frontmatter: Record<string, any>; body: string } {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = content.match(frontmatterRegex);

  if (!match) {
    return { frontmatter: {}, body: content };
  }

  try {
    const frontmatter = (yaml.load(match[1]) as Record<string, any>) || {};
    return { frontmatter, body: match[2] };
  } catch {
    return { frontmatter: {}, body: content };
  }
}

/**
 * Check if a path is an external URL
 */
function isExternalUrl(imagePath: string): boolean {
  return imagePath.startsWith('http://') || imagePath.startsWith('https://');
}

/**
 * Check if file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Extract all image references from markdown/HTML body content
 */
function extractBodyImages(body: string): string[] {
  const images: string[] = [];

  // Match markdown image syntax: ![alt](url)
  const mdRegex = /!\[.*?\]\(([^)]+\.(?:webp|png|jpg|jpeg|gif|svg|avif))\)/gi;
  let match;
  while ((match = mdRegex.exec(body)) !== null) {
    if (match[1]) images.push(match[1]);
  }

  // Match HTML img src attribute
  const htmlRegex = /<img[^>]+src=["']([^"']+\.(?:webp|png|jpg|jpeg|gif|svg|avif))["']/gi;
  while ((match = htmlRegex.exec(body)) !== null) {
    if (match[1]) images.push(match[1]);
  }

  return images;
}

/**
 * Resolve an image path to check if it exists on disk
 */
async function imageFileExists(imagePath: string, projectRoot: string, distDir: string): Promise<boolean> {
  if (imagePath.startsWith('/')) {
    // Check dist first, then public
    if (await fileExists(path.join(distDir, imagePath))) return true;
    if (await fileExists(path.join(projectRoot, 'public', imagePath))) return true;
    return false;
  }

  // Relative path - check in public
  if (await fileExists(path.join(projectRoot, 'public', imagePath))) return true;
  return false;
}

export function validateImages(): AstroIntegration {
  return {
    name: 'validate-images',
    hooks: {
      'astro:build:done': async ({ dir, logger }) => {
        const distDir = fileURLToPath(dir);
        const projectRoot = path.resolve(distDir, '..');

        // Load config for site name prefix
        const configPath = path.join(projectRoot, 'data/site-config.json');
        let config: Record<string, any> = {};
        try {
          config = JSON.parse(await fs.readFile(configPath, 'utf-8'));
        } catch {
          // Config not available, continue without prefix
        }

        const siteName = config.branding?.brand_name || config.branding?.site?.name || '';
        const prefix = siteName ? `[${siteName}] ` : '';

        logger.info(`${prefix}Validating image references in articles...`);

        const articlesDir = path.join(projectRoot, 'src/content/articles');
        const issues: ImageIssue[] = [];

        let entries: any[];
        try {
          entries = await fs.readdir(articlesDir, { withFileTypes: true, recursive: true });
        } catch {
          logger.info(`${prefix}No articles directory found, skipping image validation`);
          return;
        }

        let articlesChecked = 0;

        for (const entry of entries) {
          if (!entry.isFile()) continue;
          if (!entry.name.endsWith('.md') && !entry.name.endsWith('.mdx')) continue;

          const parentPath = entry.parentPath || entry.path || articlesDir;
          const fullPath = path.join(parentPath, entry.name);
          const relativePath = path.relative(articlesDir, fullPath);
          const slug = relativePath.replace(/\.(md|mdx)$/, '');

          const content = await fs.readFile(fullPath, 'utf-8');
          const { frontmatter, body } = parseFrontmatter(content);

          articlesChecked++;

          // Validate image_hero
          if (frontmatter.image_hero && !isExternalUrl(frontmatter.image_hero)) {
            const exists = await imageFileExists(frontmatter.image_hero, projectRoot, distDir);
            if (!exists) {
              issues.push({
                slug,
                imagePath: frontmatter.image_hero,
                source: 'image_hero',
                severity: 'error',
              });
            }
          }

          // Validate image_og (warning only - og-images integration generates these)
          if (frontmatter.image_og && !isExternalUrl(frontmatter.image_og)) {
            const exists = await imageFileExists(frontmatter.image_og, projectRoot, distDir);
            if (!exists) {
              issues.push({
                slug,
                imagePath: frontmatter.image_og,
                source: 'image_og',
                severity: 'warning',
              });
            }
          }

          // Validate body image references
          const bodyImages = extractBodyImages(body);
          for (const imgPath of bodyImages) {
            if (isExternalUrl(imgPath)) continue;
            const exists = await imageFileExists(imgPath, projectRoot, distDir);
            if (!exists) {
              issues.push({
                slug,
                imagePath: imgPath,
                source: 'body',
                severity: 'error',
              });
            }
          }
        }

        // Report results
        const errors = issues.filter((i) => i.severity === 'error');
        const warnings = issues.filter((i) => i.severity === 'warning');

        if (warnings.length > 0) {
          for (const w of warnings) {
            logger.warn(`${prefix}  [${w.source}] ${w.slug}: missing ${w.imagePath}`);
          }
        }

        if (errors.length > 0) {
          logger.error(`${prefix}Found ${errors.length} missing image(s):`);
          for (const e of errors) {
            logger.error(`${prefix}  [${e.source}] ${e.slug}: missing ${e.imagePath}`);
          }
          throw new Error(
            `Image validation failed: ${errors.length} missing image(s) in ${articlesChecked} articles. ` +
              errors.map((e) => `${e.slug} -> ${e.imagePath} (${e.source})`).join('; ')
          );
        }

        logger.info(
          `${prefix}Image validation passed: ${articlesChecked} articles checked, ${warnings.length} warning(s)`
        );
      },
    },
  };
}
